package java8.in.action.part2.chap06A;

import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;

import java8.in.action.model.Dish;
import java8.in.action.model.Inventory;

public class EGrouping15 {

	public static void main(String[] args) throws Exception {

		/*
		 * To give another example, you could rework the collector you already used to
		 * find the highest-calorie dish in the menu to achieve a similar result, but
		 * now classified by the type of dish:
		 */

		// Collectors.maxB
		{
			{

				Optional<Dish> dish = Inventory.MENU.stream()

						.collect(Collectors.maxBy(new Comparator<Dish>() {

							@Override
							public int compare(Dish o1, Dish o2) {
								return Integer.compare(o1.getCalories(), o2.getCalories());

							}
						}));

				System.out.println(dish);
			}

			{

				Optional<Dish> dish = Inventory.MENU.stream()

						.collect(Collectors.maxBy(Comparator.comparing(Dish::getCalories)));

				System.out.println(dish);
			}

		}

		// Collectors.groupingBy
		{
			Map<Dish.Type, List<Dish>> map = Inventory.MENU.stream()

					.collect(Collectors.groupingBy(Dish::getType));

			System.out.println(map);
		}

		{

			Map<Dish.Type, Optional<Dish>> map = Inventory.MENU.stream()

					.collect(Collectors.groupingBy(Dish::getType,

							Collectors.maxBy(Comparator.comparing(Dish::getCalories))));

			System.out.println(map);
		}

		/*
		 * The result of this grouping is then clearly a Map, having as keys the
		 * available types of Dishes and as values the Optional<Dish>, wrapping the
		 * corresponding highest-calorie Dish for a given type:
		 */
		{

			/*
			 * {OTHER=Optional[Dish [name=pizza, vegetarian=true, calories=550,
			 * type=OTHER]],
			 * 
			 * MEAT=Optional[Dish [name=pork, vegetarian=false, calories=800, type=MEAT]],
			 * 
			 * FISH=Optional[Dish [name=salmon, vegetarian=false, calories=450, type=FISH]]}
			 * 
			 */

			/*
			 * NOTE The values in this Map are Optionals because this is the resulting type
			 * of the collector generated by the maxBy factory method, but in reality if
			 * there’s no Dish in the menu for a given type, that type won’t have an
			 * Optional.empty() as value; it won’t be present at all as a key in the Map.
			 * 
			 * 
			 * The groupingBy collector lazily adds a new key in the grouping Map only the
			 * first time it finds an element in the stream, producing that key when
			 * applying on it the grouping criteria being used.
			 * 
			 * 
			 * This means that in this case, the Optional wrapper isn’t very useful, because
			 * it’s not modeling a value that could be eventually absent but is there
			 * incidentally, only because this is the type returned by the reducing
			 * collector.
			 */
		}

	}

}
